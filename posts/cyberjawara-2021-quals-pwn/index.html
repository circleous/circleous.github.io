<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>CyberJawara 2021 Quals - PWN | circleous</title><link rel=stylesheet href=/css/main.min.480e0ef6c6aac53eaf38419259058419b9323d67397f61cf2d8ce892d869c560.css integrity="sha256-SA4O9saqxT6vOEGSWQWEGbkyPWc5f2HPLYzokthpxWA=" crossorigin=anonymous><link rel=stylesheet href=/css/codes.min.212a1080bdb9f68724a4aff8ef71b5bf08e662a8f5ef70b13d4d94330d804899.css integrity="sha256-ISoQgL259ockpK/473G1vwjmYqj173CxPU2UMw2ASJk=" crossorigin=anonymous></head><body><header><h1><a href=/>circleous</a></h1><nav><ul><li><a href=/>Home</a></li><li><a aria-current=true class=ancestor href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li></ul></nav></header><main><article><header><h1>CyberJawara 2021 Quals - PWN</h1><time datetime=2021-11-19T00:00:00+07:00>November 19, 2021</time></header><p>Penulisan editorial berurut dari yang paling banyak dikerjakan sampai paling sedikit, <em>scroll</em> ke bawah untuk detail cara mendapatkan bounty 100k GOPAY dari soal <em>quick maffs</em>. Any question? Discord: <code>circleous#0587</code></p><h2 id=1-heapnote>1. Heapnote</h2><p>Bug pada soal terletak pada Use after Free, namun karena ukuran <code>malloc</code> statis perlu buat fake chunk terlebih dulu cukup besar untuk bisa mendapatkan unsorted bin. Detail writeup untuk soal tidak akan saya tulis karena writeup soal bertemakan heap ini sudah banyak. Tidak bermaksud untuk promosi :p, tapi series Linux Heap Exploitation dari Max Kamper <a href=https://www.udemy.com/course/linux-heap-exploitation-part-1/>https://www.udemy.com/course/linux-heap-exploitation-part-1/</a> itu bagus untuk yang lebih enak belajar dengan video.</p><h2 id=2-interview-101>2. Interview 101</h2><p>Soal ini sebenernya dibuat untuk sebagai soal paling mudah di kualifikasi, tapi ternyata yang mengerjakan sampai dapat flag tidak sebanyak soal <code>heapnote</code>. Idenya user bisa melakukan <em>dynamic allocation</em> di stack dimana bisa muncul out of bound rw access karena integer overflow saat alokasi. (size lebih dari ukuran buffer yang sebenarnya di alokasi).</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#414868;font-style:italic>// size = 0x2000000000000001
</span></span></span><span style=display:flex><span><span style=color:#414868;font-style:italic>// --&gt; alloca(0x10000000000000010)
</span></span></span><span style=display:flex><span><span style=color:#414868;font-style:italic>// --&gt; alloca(0x10)
</span></span></span><span style=display:flex><span><span style=color:#7aa2f7>alloca</span>(<span style=color:#e0af68>16</span> <span style=color:#9ece6a;font-weight:700>*</span> ((<span style=color:#e0af68>8</span> <span style=color:#9ece6a;font-weight:700>*</span> size <span style=color:#9ece6a;font-weight:700>+</span> <span style=color:#e0af68>23</span>) <span style=color:#9ece6a;font-weight:700>/</span> <span style=color:#e0af68>0x10</span>));
</span></span></code></pre></div><p>Namun, saat membuat soal ini saya justru menemukan bug lain yang bisa dilakukan.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#bb9af7>struct</span> store_s {
</span></span><span style=display:flex><span>  <span style=color:#41a6b5>unsigned</span> <span style=color:#41a6b5>long</span> size;
</span></span><span style=display:flex><span>  <span style=color:#41a6b5>char</span> name[<span style=color:#e0af68>16</span>];
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#41a6b5>void</span> <span style=color:#7aa2f7>read_buf</span>(<span style=color:#41a6b5>char</span> <span style=color:#9ece6a;font-weight:700>*</span>prompt, <span style=color:#41a6b5>char</span> <span style=color:#9ece6a;font-weight:700>*</span>buf, <span style=color:#41a6b5>size_t</span> sz) {
</span></span><span style=display:flex><span>  <span style=color:#7aa2f7>printf</span>(<span style=color:#9ece6a>&#34;%s&#34;</span>, prompt);
</span></span><span style=display:flex><span>  <span style=color:#7aa2f7>fgets</span>(buf, sz, stdin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#41a6b5>int</span> pos <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#7aa2f7>strlen</span>(buf) <span style=color:#9ece6a;font-weight:700>-</span> <span style=color:#e0af68>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#bb9af7>if</span> (buf[pos] <span style=color:#9ece6a;font-weight:700>==</span> <span style=color:#9ece6a>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>    buf[pos] <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#e0af68>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span> store.size <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#7aa2f7>read_uint</span>(<span style=color:#9ece6a>&#34;size = &#34;</span>);
</span></span><span style=display:flex><span> <span style=color:#7aa2f7>read_buf</span>(<span style=color:#9ece6a>&#34;storage name = &#34;</span>, store.name, <span style=color:#bb9af7>sizeof</span>(store.name) <span style=color:#9ece6a;font-weight:700>-</span> <span style=color:#e0af68>1</span>);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Bug kedua ini karena bisa null byte overwrite pada store.size ketika <a href=http://store.name>store.name</a> hanya berisikan null byte <code>\x00</code>. Kurang lebih begini skenarionya,</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>store.size <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#7aa2f7>read_uint</span>(<span style=color:#9ece6a>&#34;size = &#34;</span>); <span style=color:#414868;font-style:italic>// 0x0A0000...
</span></span></span><span style=display:flex><span><span style=color:#414868;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#7aa2f7>read_buf</span>(<span style=color:#9ece6a>&#34;storage name = &#34;</span>, store.name, <span style=color:#bb9af7>sizeof</span>(store.name) <span style=color:#9ece6a;font-weight:700>-</span> <span style=color:#e0af68>1</span>);
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic>// ...... di read_buf
</span></span></span><span style=display:flex><span>   <span style=color:#7aa2f7>fgets</span>(buf, sz, stdin); <span style=color:#414868;font-style:italic>// store.name = &#34;\x00&#34;
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#41a6b5>int</span> pos <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#7aa2f7>strlen</span>(buf) <span style=color:#9ece6a;font-weight:700>-</span> <span style=color:#e0af68>1</span>; <span style=color:#414868;font-style:italic>// strlen(store.name) = 0, pos = -1
</span></span></span><span style=display:flex><span>   <span style=color:#bb9af7>if</span> (buf[pos] <span style=color:#9ece6a;font-weight:700>==</span> <span style=color:#9ece6a>&#39;\n&#39;</span>) { <span style=color:#414868;font-style:italic>// store.name[-1] == 0x0a / HSB dari store.size
</span></span></span><span style=display:flex><span>     buf[pos] <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#e0af68>0</span>; <span style=color:#414868;font-style:italic>// store.size = 0x0000...
</span></span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic>// ......
</span></span></span></code></pre></div><p>Karena sudah bisa OOB (size gede banget, alokasi buffer kecil banget), tinggal leak dan overwrite saved RIP untuk ROP. Solve script, <a href=https://gist.github.com/circleous/a65f9abb768c45bf1baa5017d2ec3f5d>https://gist.github.com/circleous/a65f9abb768c45bf1baa5017d2ec3f5d</a></p><h2 id=3-catch-me-if-you-can>3. Catch me if you can</h2><p>Beberapa pekan lalu saya membuat soal backdoored qemu system escape untuk HackToday tahun ini, namun saya tarik kembali karena ternyata masih banyak masalah saat coba untuk dideploy. Ada niatan untuk release kembali soalnya untuk CJ tahun ini, tapi akhirnya saya buat lagi yang kurang lebih sama temanya. Soal ini banyak mengambil ide dari *CTF 2021 - Favourite Architecture (<a href=https://ctftime.org/task/14585>https://ctftime.org/task/14585</a>). Bedanya hanya pada restriksi syscall yang bisa dilakukan.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#e0af68;font-weight:700>diff --git a/linux-user/syscall.c b/linux-user/syscall.c
</span></span></span><span style=display:flex><span><span style=color:#e0af68;font-weight:700>index ccd3892b2..419c147a6 100644
</span></span></span><span style=display:flex><span><span style=color:#db4b4b;background-color:#15161e>--- a/linux-user/syscall.c
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+++ b/linux-user/syscall.c
</span></span></span><span style=display:flex><span><span style=color:#e0af68;font-weight:700>@@ -13144,8 +13144,19 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
</span></span></span><span style=display:flex><span>         print_syscall(cpu_env, num, arg1, arg2, arg3, arg4, arg5, arg6);
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#db4b4b;background-color:#15161e>-    ret = do_syscall1(cpu_env, num, arg1, arg2, arg3, arg4,
</span></span></span><span style=display:flex><span><span style=color:#db4b4b;background-color:#15161e>-                      arg5, arg6, arg7, arg8);
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+    switch (num) {
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+        case TARGET_NR_read:
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+        case TARGET_NR_write:
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+        case TARGET_NR_exit:
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+        case TARGET_NR_mprotect:
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+            ret = do_syscall1(cpu_env, num, arg1, arg2, arg3,
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+                              arg4, arg5, arg6, arg7, arg8);
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+            break;
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+        default:
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+            printf(&#34;[!] %d bad system call\n&#34;, num);
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+            ret = -1;
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+            break;
</span></span></span><span style=display:flex><span><span style=color:#9ece6a;background-color:#15161e>+    }
</span></span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>     if (unlikely(qemu_loglevel_mask(LOG_STRACE))) {
</span></span><span style=display:flex><span>         print_syscall_ret(cpu_env, num, ret, arg1, arg2,
</span></span></code></pre></div><p>Bug utama karena ada stack buffer overflow, jadi bisa melakukan ROP. Syscall <code>mprotect</code> bisa digunakan untuk membuat page <code>.bss</code> menjadi rwx pada context guest dan transfer dari ROP di stack ke shellcode di <code>.bss</code>. Selanjutnya untuk &ldquo;escape&rdquo; dari jail di qemu-user ini, ada beberapa cara. Intended solution menggunakan <code>mprotect</code> untuk infer address rwx qemu-user (code_gen_buffer) dan overwrite dengan shellcode execve. Solve script, <a href=https://gist.github.com/circleous/652769c669d5dae83a4eacba0a824d44>https://gist.github.com/circleous/652769c669d5dae83a4eacba0a824d44</a></p><h2 id=4-trusted-note>4. Trusted Note</h2><p>Bug banyak karena intensinya juga dibuat untuk sebagai entry challenge di linux kernel module. Intinya dengan heap overflow overwrite pointer data dan ini bisa digunakan sebagai primitive untuk arbitrary read/write. Solve script dari ramdan tim hm apa ya, <a href=https://gist.github.com/d4em0n/f94ee592ab4cc689cc91c95f7babbc67>https://gist.github.com/d4em0n/f94ee592ab4cc689cc91c95f7babbc67</a></p><h2 id=5-quick-maffs>5. Quick Maffs</h2><p>v8 type confussion, TBD. Berhubung saya masih menjalankan bounty (100k GOPAY atau e-wallet lain) untuk soal ini sampai Final Cyber Jawara 2021 (1 Desember 2021), editorial dari saya akan dirilis setelah Final CJ 2021 selesai. Rule cukup simple,</p><ol><li><del>Kirim flag ke saya (<code>circleous#0587</code>) lewat Discord</del>. Bounty taken by Linuz</li><li>Tidak curang dan tidak berbagi flag, saya akan menanyakan beberapa hal untuk konfirmasi</li></ol><div><div>Tags:</div><ul><li><a href=/tags/ctf-writeup/>Ctf-Writeup</a></li><li><a href=/tags/editorial/>Editorial</a></li><li><a href=/tags/pwn/>Pwn</a></li></ul></div></article></main><footer><p>&copy; 2025 circleous. Licensed under <a href=https://creativecommons.org/publicdomain/zero/1.0/ target=_blank>CC0</a>.</p></footer></body></html>